{"version":3,"sources":["turbopack:///[project]/src/lib/extractors/field-extractor.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma'\n\nexport interface FieldExtractionResult {\n  value: any\n  confidence: number\n  citations: Array<{\n    traceLinkId: string\n    documentId: string\n    page: number\n    snippet: string\n    relevanceScore: number\n  }>\n  metadata?: Record<string, any>\n}\n\nexport interface ExtractionPattern {\n  name: string\n  pattern: RegExp\n  valueExtractor: (match: RegExpMatchArray, context: string) => any\n  confidenceCalculator?: (match: RegExpMatchArray, context: string) => number\n}\n\nexport class FieldExtractor {\n  private patterns: Map<string, ExtractionPattern[]> = new Map()\n\n  constructor() {\n    this.initializePatterns()\n  }\n\n  private initializePatterns() {\n    // Scope patterns\n    this.patterns.set('scope', [\n      {\n        name: 'project_scope',\n        pattern: /(?:project\\s+)?scope[:\\s]*([^.]{20,200})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: (match, context) => {\n          const keywords = ['objective', 'goal', 'purpose', 'aim', 'scope']\n          const hasKeywords = keywords.some(kw => context.toLowerCase().includes(kw))\n          return hasKeywords ? 0.8 : 0.6\n        }\n      },\n      {\n        name: 'objectives',\n        pattern: /(?:objectives?|goals?|aims?)[:\\s]*([^.]{20,300})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: () => 0.9\n      }\n    ])\n\n    // Eligibility patterns\n    this.patterns.set('eligibility', [\n      {\n        name: 'eligibility_criteria',\n        pattern: /(?:eligibility|eligible|qualification)[:\\s]*([^.]{20,400})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: () => 0.9\n      },\n      {\n        name: 'requirements',\n        pattern: /(?:requirements?|criteria)[:\\s]*([^.]{20,300})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: () => 0.7\n      }\n    ])\n\n    // Evaluation criteria patterns\n    this.patterns.set('evaluationCriteria', [\n      {\n        name: 'evaluation_criteria',\n        pattern: /(?:evaluation\\s+criteria|assessment\\s+criteria)[:\\s]*([^.]{20,500})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: () => 0.95\n      },\n      {\n        name: 'scoring_criteria',\n        pattern: /(?:scoring|points?|marks?)[:\\s]*([^.]{20,300})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: () => 0.8\n      }\n    ])\n\n    // Submission mechanics patterns\n    this.patterns.set('submissionMechanics', [\n      {\n        name: 'submission_process',\n        pattern: /(?:submission|submit|how\\s+to\\s+apply)[:\\s]*([^.]{20,400})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: () => 0.9\n      },\n      {\n        name: 'application_process',\n        pattern: /(?:application\\s+process|submission\\s+method)[:\\s]*([^.]{20,300})/gi,\n        valueExtractor: (match) => match[1].trim(),\n        confidenceCalculator: () => 0.85\n      }\n    ])\n\n    // Deadline patterns\n    this.patterns.set('deadlineSubmission', [\n      {\n        name: 'deadline_date',\n        pattern: /(?:deadline|due\\s+date|closing\\s+date)[:\\s]*([^.]{5,100})/gi,\n        valueExtractor: (match) => this.extractDate(match[1]),\n        confidenceCalculator: (match) => {\n          const dateValue = this.extractDate(match[1])\n          return dateValue ? 0.9 : 0.4\n        }\n      },\n      {\n        name: 'submission_deadline',\n        pattern: /(?:submit\\s+by|submissions?\\s+must\\s+be\\s+received)[:\\s]*([^.]{5,100})/gi,\n        valueExtractor: (match) => this.extractDate(match[1]),\n        confidenceCalculator: (match) => {\n          const dateValue = this.extractDate(match[1])\n          return dateValue ? 0.85 : 0.3\n        }\n      }\n    ])\n  }\n\n  async extractField(\n    tenderId: string,\n    fieldKey: string,\n    options: {\n      requireCitations?: boolean\n      minConfidence?: number\n      maxResults?: number\n    } = {}\n  ): Promise<FieldExtractionResult> {\n    try {\n      const patterns = this.patterns.get(fieldKey)\n      if (!patterns) {\n        throw new Error(`No extraction patterns found for field: ${fieldKey}`)\n      }\n\n      // Get all trace links for this tender\n      const traceLinks = await prisma.traceLink.findMany({\n        where: {\n          document: {\n            tenderId,\n          },\n        },\n        include: {\n          document: {\n            select: { id: true, filename: true },\n          },\n        },\n      })\n\n      if (traceLinks.length === 0) {\n        throw new Error('No trace links found for tender documents')\n      }\n\n      const extractions: Array<{\n        value: any\n        confidence: number\n        traceLinkId: string\n        documentId: string\n        page: number\n        snippet: string\n        relevanceScore: number\n      }> = []\n\n      // Apply patterns to each trace link\n      for (const traceLink of traceLinks) {\n        for (const pattern of patterns) {\n          const matches = Array.from(traceLink.snippet.matchAll(pattern.pattern))\n\n          for (const match of matches) {\n            const value = pattern.valueExtractor(match, traceLink.snippet)\n            if (!value) continue\n\n            const confidence = pattern.confidenceCalculator\n              ? pattern.confidenceCalculator(match, traceLink.snippet)\n              : 0.5\n\n            if (confidence < (options.minConfidence || 0.5)) continue\n\n            const relevanceScore = this.calculateRelevanceScore(\n              fieldKey,\n              value,\n              traceLink.snippet\n            )\n\n            extractions.push({\n              value,\n              confidence,\n              traceLinkId: traceLink.id,\n              documentId: traceLink.document.id,\n              page: traceLink.page,\n              snippet: match[0],\n              relevanceScore,\n            })\n          }\n        }\n      }\n\n      if (extractions.length === 0) {\n        if (options.requireCitations) {\n          throw new Error(`No valid extractions found for field: ${fieldKey}`)\n        }\n        return {\n          value: null,\n          confidence: 0,\n          citations: [],\n        }\n      }\n\n      // Sort by relevance and confidence\n      extractions.sort((a, b) => {\n        const scoreA = (a.confidence + a.relevanceScore) / 2\n        const scoreB = (b.confidence + b.relevanceScore) / 2\n        return scoreB - scoreA\n      })\n\n      // Take the best extraction as the primary value\n      const bestExtraction = extractions[0]\n\n      // Create citation list\n      const maxResults = options.maxResults || 5\n      const citations = extractions.slice(0, maxResults).map(ext => ({\n        traceLinkId: ext.traceLinkId,\n        documentId: ext.documentId,\n        page: ext.page,\n        snippet: ext.snippet,\n        relevanceScore: ext.relevanceScore,\n      }))\n\n      // Save the extraction to database\n      await this.saveExtraction(tenderId, fieldKey, {\n        value: bestExtraction.value,\n        confidence: bestExtraction.confidence,\n        citations,\n      })\n\n      return {\n        value: bestExtraction.value,\n        confidence: bestExtraction.confidence,\n        citations,\n        metadata: {\n          totalExtractions: extractions.length,\n          pattern: 'regex-based',\n          fieldKey,\n        },\n      }\n    } catch (error) {\n      console.error(`Error extracting field ${fieldKey}:`, error)\n      throw error\n    }\n  }\n\n  private calculateRelevanceScore(fieldKey: string, value: any, context: string): number {\n    const contextLower = context.toLowerCase()\n\n    // Field-specific relevance indicators\n    const relevanceIndicators: Record<string, string[]> = {\n      scope: ['scope', 'objective', 'goal', 'purpose', 'project', 'work'],\n      eligibility: ['eligible', 'qualification', 'requirement', 'criteria', 'must'],\n      evaluationCriteria: ['evaluation', 'assess', 'score', 'criteria', 'weight'],\n      submissionMechanics: ['submit', 'application', 'process', 'method', 'how'],\n      deadlineSubmission: ['deadline', 'due', 'closing', 'submit by', 'before'],\n    }\n\n    const indicators = relevanceIndicators[fieldKey] || []\n    const foundIndicators = indicators.filter(ind => contextLower.includes(ind))\n\n    // Base score based on indicator presence\n    let score = foundIndicators.length / indicators.length\n\n    // Boost for value quality\n    if (typeof value === 'string') {\n      if (value.length > 50) score += 0.1 // Prefer longer, more detailed extractions\n      if (value.includes('shall') || value.includes('must')) score += 0.1 // Legal language\n    }\n\n    // Boost for date fields with valid dates\n    if (fieldKey === 'deadlineSubmission' && value instanceof Date) {\n      score += 0.2\n    }\n\n    return Math.min(score, 1.0)\n  }\n\n  private extractDate(text: string): Date | null {\n    try {\n      // Common date patterns\n      const patterns = [\n        /(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})/,\n        /(\\d{4})[\\/\\-](\\d{1,2})[\\/\\-](\\d{1,2})/,\n        /(\\d{1,2})\\s+(January|February|March|April|May|June|July|August|September|October|November|December)\\s+(\\d{4})/i,\n        /(January|February|March|April|May|June|July|August|September|October|November|December)\\s+(\\d{1,2}),?\\s+(\\d{4})/i,\n      ]\n\n      for (const pattern of patterns) {\n        const match = text.match(pattern)\n        if (match) {\n          const date = new Date(text)\n          if (!isNaN(date.getTime())) {\n            return date\n          }\n        }\n      }\n\n      // Try direct parsing\n      const date = new Date(text.trim())\n      if (!isNaN(date.getTime())) {\n        return date\n      }\n\n      return null\n    } catch {\n      return null\n    }\n  }\n\n  private async saveExtraction(\n    tenderId: string,\n    fieldKey: string,\n    extraction: {\n      value: any\n      confidence: number\n      citations: Array<{ traceLinkId: string }>\n    }\n  ): Promise<void> {\n    try {\n      // Upsert field extraction\n      await prisma.fieldExtraction.upsert({\n        where: {\n          tenderId_key: { tenderId, key: fieldKey },\n        },\n        create: {\n          tenderId,\n          key: fieldKey,\n          value: extraction.value,\n          confidence: extraction.confidence,\n          traceLinks: {\n            connect: extraction.citations.map(c => ({ id: c.traceLinkId })),\n          },\n        },\n        update: {\n          value: extraction.value,\n          confidence: extraction.confidence,\n          traceLinks: {\n            set: extraction.citations.map(c => ({ id: c.traceLinkId })),\n          },\n        },\n      })\n    } catch (error) {\n      console.error('Error saving extraction:', error)\n      throw new Error('Failed to save field extraction')\n    }\n  }\n\n  async validateExtractions(tenderId: string): Promise<{\n    isValid: boolean\n    missingFields: string[]\n    lowConfidenceFields: string[]\n    fieldsWithoutCitations: string[]\n  }> {\n    try {\n      const requiredFields = ['scope', 'eligibility', 'evaluationCriteria', 'submissionMechanics', 'deadlineSubmission']\n      const minConfidence = 0.5\n\n      const extractions = await prisma.fieldExtraction.findMany({\n        where: { tenderId },\n        include: { traceLinks: true },\n      })\n\n      const extractedFields = new Set(extractions.map(e => e.key))\n      const missingFields = requiredFields.filter(field => !extractedFields.has(field))\n\n      const lowConfidenceFields = extractions\n        .filter(e => e.confidence < minConfidence)\n        .map(e => e.key)\n\n      const fieldsWithoutCitations = extractions\n        .filter(e => e.traceLinks.length === 0)\n        .map(e => e.key)\n\n      const isValid = missingFields.length === 0 &&\n                     lowConfidenceFields.length === 0 &&\n                     fieldsWithoutCitations.length === 0\n\n      return {\n        isValid,\n        missingFields,\n        lowConfidenceFields,\n        fieldsWithoutCitations,\n      }\n    } catch (error) {\n      console.error('Error validating extractions:', error)\n      throw new Error('Failed to validate extractions')\n    }\n  }\n}\n\nexport const fieldExtractor = new FieldExtractor()"],"names":[],"mappings":"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"}
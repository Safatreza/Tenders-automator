{"version":3,"sources":["turbopack:///[project]/src/lib/extractors/checklist-generator.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma'\nimport { ChecklistStatus } from '@prisma/client'\n\nexport interface ChecklistGenerationResult {\n  items: Array<{\n    key: string\n    label: string\n    status: ChecklistStatus\n    notes?: string\n    traceLinkIds: string[]\n    autoChecked: boolean\n  }>\n  metadata: {\n    templateId: string\n    generatedAt: Date\n    totalItems: number\n    autoCheckedItems: number\n    requiresManualReview: number\n  }\n}\n\nexport interface ChecklistRule {\n  key: string\n  name: string\n  description: string\n  autoCheck: {\n    enabled: boolean\n    field?: string\n    condition?: {\n      operator: 'contains' | 'equals' | 'exists' | 'matches' | 'date_before' | 'date_after'\n      value?: any\n      caseSensitive?: boolean\n    }\n  }\n  required: boolean\n}\n\nexport class ChecklistGenerator {\n  private autoCheckRules: Map<string, ChecklistRule> = new Map()\n\n  constructor() {\n    this.initializeRules()\n  }\n\n  private initializeRules() {\n    // Tax Certificate Rule\n    this.autoCheckRules.set('tax-certificate', {\n      key: 'tax-certificate',\n      name: 'Tax Certificate',\n      description: 'Valid tax certificate or clearance required',\n      autoCheck: {\n        enabled: true,\n        field: 'eligibility',\n        condition: {\n          operator: 'contains',\n          value: 'tax',\n          caseSensitive: false,\n        },\n      },\n      required: true,\n    })\n\n    // ISO 9001 Rule\n    this.autoCheckRules.set('iso-9001', {\n      key: 'iso-9001',\n      name: 'ISO 9001 Certification',\n      description: 'ISO 9001 quality management certification',\n      autoCheck: {\n        enabled: true,\n        field: 'eligibility',\n        condition: {\n          operator: 'contains',\n          value: 'iso',\n          caseSensitive: false,\n        },\n      },\n      required: false,\n    })\n\n    // Financial Statements Rule\n    this.autoCheckRules.set('financial-statements', {\n      key: 'financial-statements',\n      name: 'Financial Statements',\n      description: 'Audited financial statements for last 3 years',\n      autoCheck: {\n        enabled: true,\n        field: 'eligibility',\n        condition: {\n          operator: 'contains',\n          value: 'financial',\n          caseSensitive: false,\n        },\n      },\n      required: true,\n    })\n\n    // Technical Specifications Rule\n    this.autoCheckRules.set('technical-specifications', {\n      key: 'technical-specifications',\n      name: 'Technical Specifications',\n      description: 'Detailed technical specifications and drawings',\n      autoCheck: {\n        enabled: true,\n        field: 'submissionMechanics',\n        condition: {\n          operator: 'contains',\n          value: 'technical',\n          caseSensitive: false,\n        },\n      },\n      required: true,\n    })\n\n    // Legal Compliance Rule\n    this.autoCheckRules.set('legal-compliance', {\n      key: 'legal-compliance',\n      name: 'Legal Compliance',\n      description: 'Legal compliance and regulatory requirements',\n      autoCheck: {\n        enabled: true,\n        field: 'eligibility',\n        condition: {\n          operator: 'contains',\n          value: 'legal',\n          caseSensitive: false,\n        },\n      },\n      required: true,\n    })\n\n    // Insurance Coverage Rule\n    this.autoCheckRules.set('insurance-coverage', {\n      key: 'insurance-coverage',\n      name: 'Insurance Coverage',\n      description: 'Professional indemnity and public liability insurance',\n      autoCheck: {\n        enabled: true,\n        field: 'eligibility',\n        condition: {\n          operator: 'contains',\n          value: 'insurance',\n          caseSensitive: false,\n        },\n      },\n      required: false,\n    })\n\n    // Company Registration Rule\n    this.autoCheckRules.set('company-registration', {\n      key: 'company-registration',\n      name: 'Company Registration',\n      description: 'Valid company registration certificate',\n      autoCheck: {\n        enabled: true,\n        field: 'eligibility',\n        condition: {\n          operator: 'contains',\n          value: 'registration',\n          caseSensitive: false,\n        },\n      },\n      required: true,\n    })\n\n    // Deadline Compliance Rule\n    this.autoCheckRules.set('deadline-compliance', {\n      key: 'deadline-compliance',\n      name: 'Deadline Compliance',\n      description: 'Submission before deadline',\n      autoCheck: {\n        enabled: true,\n        field: 'deadlineSubmission',\n        condition: {\n          operator: 'date_after',\n          value: new Date(),\n        },\n      },\n      required: true,\n    })\n  }\n\n  async generateChecklist(\n    tenderId: string,\n    templateId: string,\n    options: {\n      autoCheck?: boolean\n      requiredItemsOnly?: boolean\n    } = {}\n  ): Promise<ChecklistGenerationResult> {\n    try {\n      // Get template\n      const template = await prisma.template.findUnique({\n        where: { id: templateId },\n      })\n\n      if (!template || template.kind !== 'CHECKLIST') {\n        throw new Error('Checklist template not found')\n      }\n\n      // Get extracted fields for auto-checking\n      const fieldExtractions = await prisma.fieldExtraction.findMany({\n        where: { tenderId },\n        include: {\n          traceLinks: {\n            select: { id: true },\n          },\n        },\n      })\n\n      const fieldsMap = new Map(fieldExtractions.map(f => [f.key, f]))\n\n      // Get template schema\n      const templateSchema = template.schema as {\n        categories: Array<{\n          key: string\n          name: string\n          items: Array<{\n            key: string\n            label: string\n            required: boolean\n            autoCheck?: any\n          }>\n        }>\n      }\n\n      const items: Array<{\n        key: string\n        label: string\n        status: ChecklistStatus\n        notes?: string\n        traceLinkIds: string[]\n        autoChecked: boolean\n      }> = []\n\n      let autoCheckedCount = 0\n      let requiresManualReview = 0\n\n      // Process all items from template\n      for (const category of templateSchema.categories) {\n        for (const templateItem of category.items) {\n          // Skip non-required items if requiredItemsOnly is true\n          if (options.requiredItemsOnly && !templateItem.required) {\n            continue\n          }\n\n          const rule = this.autoCheckRules.get(templateItem.key)\n          let status: ChecklistStatus = 'PENDING'\n          let notes: string | undefined\n          let traceLinkIds: string[] = []\n          let autoChecked = false\n\n          // Perform auto-check if enabled\n          if (options.autoCheck !== false && rule?.autoCheck.enabled) {\n            const autoCheckResult = await this.performAutoCheck(rule, fieldsMap)\n            status = autoCheckResult.status\n            notes = autoCheckResult.notes\n            traceLinkIds = autoCheckResult.traceLinkIds\n            autoChecked = autoCheckResult.autoChecked\n\n            if (autoChecked) {\n              autoCheckedCount++\n            }\n          }\n\n          if (status === 'PENDING') {\n            requiresManualReview++\n          }\n\n          items.push({\n            key: templateItem.key,\n            label: templateItem.label,\n            status,\n            notes,\n            traceLinkIds,\n            autoChecked,\n          })\n        }\n      }\n\n      // Save checklist items to database\n      await this.saveChecklistItems(tenderId, items)\n\n      return {\n        items,\n        metadata: {\n          templateId,\n          generatedAt: new Date(),\n          totalItems: items.length,\n          autoCheckedItems: autoCheckedCount,\n          requiresManualReview,\n        },\n      }\n    } catch (error) {\n      console.error('Error generating checklist:', error)\n      throw error\n    }\n  }\n\n  private async performAutoCheck(\n    rule: ChecklistRule,\n    fieldsMap: Map<string, any>\n  ): Promise<{\n    status: ChecklistStatus\n    notes?: string\n    traceLinkIds: string[]\n    autoChecked: boolean\n  }> {\n    try {\n      if (!rule.autoCheck.field || !rule.autoCheck.condition) {\n        return {\n          status: 'PENDING',\n          traceLinkIds: [],\n          autoChecked: false,\n        }\n      }\n\n      const field = fieldsMap.get(rule.autoCheck.field)\n      if (!field) {\n        return {\n          status: 'MISSING',\n          notes: `Required field '${rule.autoCheck.field}' not found`,\n          traceLinkIds: [],\n          autoChecked: true,\n        }\n      }\n\n      const condition = rule.autoCheck.condition\n      const fieldValue = field.value\n      const traceLinkIds = field.traceLinks.map((link: any) => link.id)\n\n      let matches = false\n\n      switch (condition.operator) {\n        case 'contains':\n          if (typeof fieldValue === 'string') {\n            const searchValue = condition.caseSensitive\n              ? condition.value\n              : condition.value.toLowerCase()\n            const fieldText = condition.caseSensitive\n              ? fieldValue\n              : fieldValue.toLowerCase()\n            matches = fieldText.includes(searchValue)\n          }\n          break\n\n        case 'equals':\n          matches = fieldValue === condition.value\n          break\n\n        case 'exists':\n          matches = fieldValue != null && fieldValue !== ''\n          break\n\n        case 'matches':\n          if (typeof fieldValue === 'string' && condition.value) {\n            const regex = new RegExp(condition.value, condition.caseSensitive ? 'g' : 'gi')\n            matches = regex.test(fieldValue)\n          }\n          break\n\n        case 'date_after':\n          if (fieldValue instanceof Date && condition.value instanceof Date) {\n            matches = fieldValue > condition.value\n          }\n          break\n\n        case 'date_before':\n          if (fieldValue instanceof Date && condition.value instanceof Date) {\n            matches = fieldValue < condition.value\n          }\n          break\n      }\n\n      return {\n        status: matches ? 'OK' : (rule.required ? 'MISSING' : 'PENDING'),\n        notes: matches\n          ? `Auto-checked: Found evidence in ${rule.autoCheck.field}`\n          : `Auto-checked: No evidence found in ${rule.autoCheck.field}`,\n        traceLinkIds,\n        autoChecked: true,\n      }\n    } catch (error) {\n      console.error('Error in auto-check:', error)\n      return {\n        status: 'PENDING',\n        notes: 'Auto-check failed, manual review required',\n        traceLinkIds: [],\n        autoChecked: false,\n      }\n    }\n  }\n\n  private async saveChecklistItems(\n    tenderId: string,\n    items: Array<{\n      key: string\n      label: string\n      status: ChecklistStatus\n      notes?: string\n      traceLinkIds: string[]\n    }>\n  ): Promise<void> {\n    try {\n      for (const item of items) {\n        await prisma.checklistItem.upsert({\n          where: {\n            tenderId_key: {\n              tenderId,\n              key: item.key,\n            },\n          },\n          create: {\n            tenderId,\n            key: item.key,\n            label: item.label,\n            status: item.status,\n            notes: item.notes,\n            traceLinks: {\n              connect: item.traceLinkIds.map(id => ({ id })),\n            },\n          },\n          update: {\n            status: item.status,\n            notes: item.notes,\n            traceLinks: {\n              set: item.traceLinkIds.map(id => ({ id })),\n            },\n          },\n        })\n      }\n    } catch (error) {\n      console.error('Error saving checklist items:', error)\n      throw new Error('Failed to save checklist items')\n    }\n  }\n\n  async updateChecklistItem(\n    tenderId: string,\n    itemKey: string,\n    update: {\n      status: ChecklistStatus\n      notes?: string\n    }\n  ): Promise<void> {\n    try {\n      await prisma.checklistItem.update({\n        where: {\n          tenderId_key: {\n            tenderId,\n            key: itemKey,\n          },\n        },\n        data: {\n          status: update.status,\n          notes: update.notes,\n          updatedAt: new Date(),\n        },\n      })\n    } catch (error) {\n      console.error('Error updating checklist item:', error)\n      throw new Error('Failed to update checklist item')\n    }\n  }\n\n  async getChecklist(tenderId: string): Promise<Array<{\n    key: string\n    label: string\n    status: ChecklistStatus\n    notes?: string\n    traceLinks: Array<{\n      id: string\n      page: number\n      snippet: string\n      documentId: string\n    }>\n    updatedAt: Date\n  }>> {\n    try {\n      const checklistItems = await prisma.checklistItem.findMany({\n        where: { tenderId },\n        include: {\n          traceLinks: {\n            select: {\n              id: true,\n              page: true,\n              snippet: true,\n              documentId: true,\n            },\n          },\n        },\n        orderBy: { key: 'asc' },\n      })\n\n      return checklistItems.map(item => ({\n        key: item.key,\n        label: item.label,\n        status: item.status,\n        notes: item.notes || undefined,\n        traceLinks: item.traceLinks,\n        updatedAt: item.updatedAt,\n      }))\n    } catch (error) {\n      console.error('Error getting checklist:', error)\n      throw new Error('Failed to get checklist')\n    }\n  }\n\n  async validateChecklist(tenderId: string): Promise<{\n    isComplete: boolean\n    canApprove: boolean\n    pendingItems: string[]\n    missingItems: string[]\n    statistics: {\n      total: number\n      ok: number\n      missing: number\n      pending: number\n      notApplicable: number\n    }\n  }> {\n    try {\n      const checklistItems = await prisma.checklistItem.findMany({\n        where: { tenderId },\n      })\n\n      const statistics = {\n        total: checklistItems.length,\n        ok: 0,\n        missing: 0,\n        pending: 0,\n        notApplicable: 0,\n      }\n\n      const pendingItems: string[] = []\n      const missingItems: string[] = []\n\n      checklistItems.forEach(item => {\n        switch (item.status) {\n          case 'OK':\n            statistics.ok++\n            break\n          case 'MISSING':\n            statistics.missing++\n            missingItems.push(item.key)\n            break\n          case 'PENDING':\n            statistics.pending++\n            pendingItems.push(item.key)\n            break\n          case 'N_A':\n            statistics.notApplicable++\n            break\n        }\n      })\n\n      const isComplete = pendingItems.length === 0 && missingItems.length === 0\n      const canApprove = isComplete // Can only approve if all items are resolved\n\n      return {\n        isComplete,\n        canApprove,\n        pendingItems,\n        missingItems,\n        statistics,\n      }\n    } catch (error) {\n      console.error('Error validating checklist:', error)\n      throw new Error('Failed to validate checklist')\n    }\n  }\n\n  async bulkUpdateChecklist(\n    tenderId: string,\n    updates: Array<{\n      key: string\n      status: ChecklistStatus\n      notes?: string\n    }>\n  ): Promise<void> {\n    try {\n      await prisma.$transaction(\n        updates.map(update =>\n          prisma.checklistItem.update({\n            where: {\n              tenderId_key: {\n                tenderId,\n                key: update.key,\n              },\n            },\n            data: {\n              status: update.status,\n              notes: update.notes,\n              updatedAt: new Date(),\n            },\n          })\n        )\n      )\n    } catch (error) {\n      console.error('Error bulk updating checklist:', error)\n      throw new Error('Failed to bulk update checklist')\n    }\n  }\n}\n\nexport const checklistGenerator = new ChecklistGenerator()"],"names":[],"mappings":"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"}